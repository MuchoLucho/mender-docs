---
title: Supported subsystems
taxonomy:
    category: docs
    label: user guide
---


## Log

The log subsystem will look for a log pattern or a data stream. 


```
#                       "Subsystem"     "Check name"          "Log Pattern"      "Log file or data stream"             "[Optional] Log pattern expiration"
mender-monitorctl create    log         crasher_app             ERROR               /root/crasher.log                                  5
```

Arguments:

* Log Pattern - the regex pattern to look for withing the log content
* Log file or data stream - the source of the log content
* [Optional] Log pattern expiration  - time that needs to pass until the pattern match is considered invalidated
    * i.e. if ERROR is detected once and no new errors are detected in the next 5 seconds, monitoring will report all issues were resolved.
    * if nothing is specified the [DEFAULT_LOG_PATTERN_EXPIRATION_SECONDS](../30.Advanced-configuration/docs.md#DEFAULT_LOG_PATTERN_EXPIRATION_SECONDS) is used

The log monitoring subsystem saves the number of the last line of logs that
it parsed and starts tailing the file skipping the already seen lines.

The log monitoring subsystem uses the `grep` command to match lines to a given pattern
By default, and if supported by `grep` we use the `-P` option, which allows you to use
the [Perl-compatible regular expressions](https://www.pcre.org/).
If you have no support for `-P`, it falls back to the `-E` flag, and
eventually uses plain `grep`.

### Capturing logs from data streams

Any command that produces data on standard output can be used as the data source in which to look for patterns.

The general syntax to enable the streamline logs extension is to use `@` with the command what should provide a stream of logs:


```bash
#                       "Subsystem"     "Check name"             "Log Pattern"                  "Log file or data stream"    "[Optional] Log pattern expiration"
mender-monitorctl create    log         crasher_app     ".*container kill.*name=scanner.*"          "@docker events"                        5
```




## D-Bus

TODO: Not really sure what is what sensible things to use here. Would go for a simple dbus service, not sure which one

```bash
#                         "Subsystem"     "Check name"      "Dbus name"      "Dbus pattern"       "Dbus watch expression" 
mender-monitorctl create     dbus          dbus_check          upower            ""                       " "
```


Arguments:

* Dbus name - the regex pattern to look for withing the log content
* Dbus pattern - Log file or data stream - the source of the log content
* Dbus watch expression   - time that needs to pass until the pattern match is considered invalidated



## Service

The service subsystem is mostly useful for tracking systemd services.
It will trigger an alert if detects the systemd service isn't running.
It has a perculiarity compared to the other services where the check name is used as a parameter for the subsystem


```
#                         "Subsystem"     "Check name"          "Service type" 
mender-monitorctl create    service           cron                  systemd           
```

Arguments:

* Check name - this server both as a check name and as the name of the service to 
* Service name - the systemd service to check for 




TODO: The old docs mention a 'pseudo subsystem' as well. How to create those? Am thinking this should be in the advanced case


```
Docker events
The log subsystem is a base for so-called pseudo subsystems. One of them is the dockerevents subsystem, which you can use to monitor any events as reported by docker events command.

For instance, to monitor for kill event on a container named scanner you need to create a check with mender-monitorctl command and enable it in the following way:

sudo mender-monitorctl create dockerevents scanner_kill scanner kill 16
sudo mender-monitorctl enable dockerevents scanner_kill
sudo systemctl restart mender-monitor
copy
With the above configuration you will receive a CRITICAL alert if someone or something kills your scanner container. This will lead the Mender UI to present the device in a critical monitoring state. Since there is no natural way to recover from this situation, we are using the last and optional argument to the mender-monitorctl create dockerevents command which stands for the number of seconds after which the Mender Monitor daemon sends an automatic OK. In that way after 16s without a kill event on the container the device will recover to normal state.

The resulting check uses the log monitor, as you can see with:

cat /etc/mender-monitor/monitor.d/available/log_scanner_kill.sh
copy
# This file was autogenerated by Monitoring Utilities based on the configuration
SERVICE_NAME="scanner_kill"
LOG_PATTERN=".*container kill.*name=scanner.*"
LOG_FILE="@docker events"
LOG_PATTERN_EXPIRATION=16
LOG_ALERT_DESCRIPTION="Docker container scanner kill"
LOG_ALERT_DETAILS="Alert was raised due to:%line_matching"
LOG_ALERT_STATUS=DOCKEREVENTS_CONTAINER_RESTART
LOG_ALERT_TYPE=docker_event
```
