---
title: Supported subsystems
taxonomy:
    category: docs
    label: user guide
---


## Log

The log subsystem will look for a log pattern or a data stream. 

Arguments:

* Log Pattern - the regex pattern to look for withing the log content
* Log file or data stream - the source of the log content
* [Optional] Log pattern expiration  - time that needs to pass until the pattern match is considered invalidated
    * As an example, if ERROR is detected once and no new errors are detected in the next 5 seconds, monitoring will report all issues were resolved
    * If nothing is specified the [DEFAULT_LOG_PATTERN_EXPIRATION_SECONDS](../30.Advanced-configuration/docs.md#DEFAULT_LOG_PATTERN_EXPIRATION_SECONDS) is used

The log monitoring subsystem saves the number of the last line of logs that
it parsed and starts tailing the file skipping the already seen lines.

The log monitoring subsystem uses the `grep` command to match lines to a given pattern
By default, and if supported by `grep` we use the `-P` option, which allows you to use
the [Perl-compatible regular expressions](https://www.pcre.org/).
If you have no support for `-P`, it falls back to the `-E` flag, and
eventually uses plain `grep`.


### Capturing logs from log files
The general syntax to enable a check for a pattern in a specific file is as follows:

```
#                       "Subsystem"     "Check name"          "Log Pattern"      "Log file or data stream"             "[Optional] Log pattern expiration"
mender-monitorctl create    log         crasher_app             ERROR               /root/crasher.log                                  5
```


### Capturing logs from data streams

Any command that produces data on standard output can be used as the data source in which to look for patterns.

The general syntax to enable the streamline logs extension is to use `@` with the command what should provide a stream of logs:

```bash
#                       "Subsystem"     "Check name"             "Log Pattern"                  "Log file or data stream"    "[Optional] Log pattern expiration"
mender-monitorctl create    log         crasher_app     ".*container kill.*name=scanner.*"          "@docker events"                        5
```

### Capturing Docker events

The log subsystem is a base for so-called _pseudo subsystems_. The `dockerevents` pseudo subsystem, can be used to generate a check to monitor any events as reported by `docker events`
command.

The `dockerevents` definition can be found in the `mender-monitor` library source code:

```bash
cat /usr/share/mender-monitor/lib/ctl-lib.sh
```

> ```bash
> ...
> function ctl_create_dockerevents_subsystem_entry() {
>     local -r service_name="$1"
>     local -r container_name="$2"
>     local -r action_name="$3"
> 
>     EXTRA_SETTINGS="LOG_ALERT_DESCRIPTION=\"Docker container ${container_name} ${action_name}\"\nLOG_ALERT_DETAILS=\"Alert was raised due to:%line_matching\"\nLOG_ALERT_STATUS=DOCKEREVENTS_CONTAINER_EVENT\nLOG_ALERT_TYPE=docker_event\n" ctl_create_log_subsystem_entry "$service_name" ".*container ${action_name}.*name=${container_name}.*" "@docker events" "$4"
> }
> 
> declare -A SUBSYSTEMS_NAME_TO_SUBSYSTEM=([dockerevents]="log")
> ...
> ```

From the previous code, you can see it predefines the required variables for the log subsystem to function, and creates the check just like a regular log check.

Using this pseudo subsystem makes the creation of checks easier:

```bash
mender-monitorctl create dockerevents scanner_kill scanner kill 16
mender-monitorctl enable dockerevents scanner_kill
systemctl restart mender-monitor
```

This commands will create the Check `log_scanner_kill.sh` in the folder `/etc/mender-monitor/monitor.d/available/`. The resulting check uses the log monitor, as you can see with:


```bash
cat /etc/mender-monitor/monitor.d/available/log_scanner_kill.sh
```
> ```bash
> # This file was autogenerated by Monitoring Utilities based on the configuration
> SERVICE_NAME="scanner_kill"
> LOG_PATTERN=".*container kill.*name=scanner.*"
> LOG_FILE="@docker events"
> LOG_PATTERN_EXPIRATION=16
> LOG_ALERT_DESCRIPTION="Docker container scanner kill"
> LOG_ALERT_DETAILS="Alert was raised due to:%line_matching"
> LOG_ALERT_STATUS=DOCKEREVENTS_CONTAINER_RESTART
> LOG_ALERT_TYPE=docker_event
> ```

With the above configuration you will receive a `CRITICAL` alert if someone or something kills your scanner container.
This will lead the Mender UI to present the device in a critical monitoring state. Since there is no natural
way to recover from this situation, we are using the last and optional argument
to the `mender-monitorctl create dockerevents` command which stands for the number of seconds
after which the Mender Monitor daemon sends an automatic _OK_. In that way after 16s without
a `kill` event on the container the device will recover to normal state.

## D-Bus

Every time a D-Bus signal matching the watch expression is received, it will trigger a check that will send an alert from the monitoring subsystem. You can adapt the configuration to any D-Bus signal and pattern based on your use case.

Let's assume you want to raise an alert every time `u-power` raises a signal. To this end you need to create the check with as follows:

```bash
#                         "Subsystem"     "Check name"      "Dbus name"      "Dbus pattern"       "Dbus watch expression"                                                                                       "[Optional] Dbus alert expiration"
mender-monitorctl create     dbus          dbus_check          u-power            ""              "type='signal',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged',path=/org/freedesktop/UPower/devices/battery_BAT0"   5
```

Arguments:

* Dbus name - the name of the watcher
* Dbus pattern - the grep pattern to match on (in the example above empty to match on all notifications)
* Dbus watch expression - the watch pattern passed to dbus-monitor (can be empty)
* [Optional] Dbus alert expiration  - time that needs to pass until the pattern match is considered invalidated
    * i.e. if ERROR is detected once and no new errors are detected in the next 5 seconds, monitoring will report all issues were resolved.
    * if nothing is specified the `DEFAULT_DBUS_ALERT_EXPIRATION_SECONDS` is used.


## Service

The service subsystem is mostly useful for tracking systemd services.
It will trigger an alert if detects the systemd service isn't running.
It has a perculiarity compared to the other services where the check name is used as a parameter for the subsystem


```
#                         "Subsystem"     "Check name"          "Service type" 
mender-monitorctl create    service           cron                  systemd           
```

Arguments:

* Check name - this server both as a check name and as the name of the service to 
* Service name - the systemd service to check for 




